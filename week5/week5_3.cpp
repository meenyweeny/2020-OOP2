#include<iostream>
using namespace std;

//동적 메모리 할당
//메모리를 다루는 방법 중 하나

//메모리 할당
//컴퓨터로부터 필요한만큼 메모리 공간을 얻어오는 것 (요청하는 것)

//동적 메모리 할당
//static의 반대의 의미
//내가 요청하고자 하는 메모리의 크기가 컴파일의 시점에 정해지는 것이 아니고
//프로그램이 돌아가는 도중에도 동적으로 필요에 의해서 할당

//예제1
/*
int main() {
	int * p;
	int length, total = 0;
	double average;
	cin >> length;
	p = new int[length]; //동적 메모리 할당
	//너무 크게 요구하면 문제가 될 수 있음

	for (int i = 0; i < length; i++) {
		cin >> *(p + i);
	}
	for (int i = 0; i < length; i++) {
		total = total + p[i];
	}
	average = total / (double)length;
	cout << total << endl;
	cout << average << endl;


	//new에서 할당했으면 반드시 delete 해줘야함
	//하나면 그냥 delete로 해주면 되는데 지금 사용한건 배열임
	//그럼 대괄호가 붙어야함
	
	delete[] p; //사용한 메모리 해제
}
*/

//예제2
/*
int main() {
	int * p = new int; //선언과 동시에 동적할당
	//포인터는 무조건 4바이트
	//포인터 공간에 동적할당 받은 공간의 번지수가 들어가있다고 생각하면 됨
	//50,54,58 메모리 공간에서 50이 p의 번지수고 얘가 동적할당을 받았으면
	//10,14,18 에서 14를 동적할당 해줬으면 50이라는 메모리 공간에 14라는 주소가
	//들어가고 14라는 메모리 공간을 포인팅함
	//그리고 p가 가리키는(포인팅) 하는 곳에 486이라는 값을 집어넣는거

	//운영체제가 어딘가의 주소를 동적할당 해줌
	*p = 486;
	cout << *p << endl;

	delete p; //해제
	//해제 안해도 돌아가긴 함
	//근데 사용되지 않는데 남아있어서 메모리누수 발생하거나 이럴수도 있음
	//그니까 하는게 안전
	//포인팅하는 연결을 끊어버리는 거 그러니까 더 이상 못 씀



	//만약 크기 3인 배열이라면 4*3 12바이트의 크기 공간이 할당하고
	//포인터가 그 중 맨 앞 번지의 주소를 가리키고 있는 것
	//그래서 delete[] 이렇게 대괄호를 넣어줘야 함

	//해제했는데 또 해제하면 안됨
	//초기화되지않은 메모리라고 뜸
}
*/

int main() {
	short * p = new short[100]; //200바이트 동적할당
	cout << p << endl; //메모리 번지주소
	delete[] p;
	p = NULL;
	cout << p << endl; //해제하고 다시 주소 찍어봄
	//4byte 형태로 표기가 됨(메모리 번지 주소니까)
	delete[] p; //또 해제
	p = NULL;

	//p=NULL안해도 나오긴 나옴
	//그러나 문제가 있음
	//해제를 했는데도 불구하고 200바이트의 공간은 해제가 됐는데
	//포인터가 어딘가를 가리키고 있는 주소값을 보관하는 것은 살아있음
	//그러므로 p에 null값을 넣어주어야 함
}