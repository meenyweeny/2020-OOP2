#include<iostream>
using namespace std;

int main() {
	//포인터 간의 덧셈 뺄셈
	//포인터는 다음 원소의 위치로 이동해주게 함
	//포인터가 가리키는 대상의 size 단위로 증가 (int면 4씩 증가)

	/*
	int arr[5];
	//int* parr = &arr[0]; == //int * parr = arr;
	int * parr = &arr[2];

	cout << parr << endl;
	cout << parr+1 << endl; //int타입이니까 더하기 1이 1증가가아니라 주소값 4증가
	cout << parr+2 << endl;
	*/

	//==============================================================

	/*
	short arrr[5];
	//int* parr = &arr[0]; == //int * parr = arr;
	short * parrr = &arrr[2];
	//정확히 내가 지정하는 대상이 얼마만큼의 size를 가지고있고, 어떤 타입인지 알아서 쉽게 출력 가능

	//근데 void 타입은 어떤것이든 받을 수 있었지만
	//출력시점에 정확하게 내가 가리키는 대상의 size를 알려줘야 얼마만큼 찍을지
	//정수인지 실수인지 출력 시점에 알려줘야한다. 주의를 기울여야 한다.

	cout << parrr << endl;
	cout << parrr + 1 << endl; //short타입이니까 더하기 1이 1증가가아니라 주소값 2증가
	cout << parrr + 2 << endl;
	cout << parrr - 2 << endl;
	//상수형태로 빼기 더하기를 함



	//즉 배열 안 원소의 타입에 따라 주소의 간격은 달라질 수 있다.
	*/

	//==============================================================

	/*
	//포인터 간의 덧셈뺄셈도 가능
	short arr[5];
	short * p1 = &arr[1];
	short * p2 = &arr[4];

	cout << p1 << endl;
	cout << p2 << endl;
	cout << p2 - p1 << endl;
	//뺼셈은 원소의 차를 얘기하는거
	//(메모리 번지 주소는 6이 차이나는데 이 결과를 출력하는게 아니라)
	//(이 사이의 간격이 3이라는 것을 출력해서 출력이 3으로 나옴)
	*/

	//==============================================================

	/*
	int arr[5];
	int * p1 = &arr[1];
	int * p2 = &arr[4];

	cout << p1 << endl;
	cout << p2 << endl;
	//산술적으로 이 두 주소값은 12byte의 차이가 발생함

	cout << p2 - p1 << endl;
	//short type일때랑 똑같이 원소의 gap은 3임을 나타냄.
	//포인터에 상수 덧셈 뺄셈을 하건 포인터 간의 덧셈 뺄셈을 하건
	//그 gap단위로 움직임을 알 수 있다(원소의 크기 단위로)
	//(단순한 산술 연산이 아니라)
	*/

	//==============================================================

	//배열포인터
	/*
	long arry[10];
	long(*p)[10] = &arry; //앰퍼센드 꼭 붙여줘야함
	//선언시 내가 가리킬 대상의 size도 써줘야함

	(*p)[5] = 100;
	cout << arry[5] << endl; //100이 출력됨
	cout << (*p)[5] << endl; //배열 포인터를 사용한 출력
	cout << arry[4] << endl; //초기화 안해서 더미값 출력됨

	*p[2] = 100; //괄호를 안쓰면 안된다
	cout << arry[2] << endl; //괄호를 안써서 예상치 못한 쓰레기값이 나옴

	//내가 직접 메모리 번지수 관리하는건 좋지만
	//포인터를 잘 쓰기는 어렵다
	*/

	//==============================================================

	//포인터 배열
	
	short a, b, c=5,d=2;
	short * arr[4];
	arr[0] = &a;
	arr[1] = &b;
	arr[2] = &c;
	arr[3] = &d;

	cout << arr[0] << endl; //a의 주소
	cout << arr[1] << endl; //b의 주소
	cout << arr[2] << endl; //c의 주소
	cout << arr[3] << endl; //d의 주소
	//주소값이 연달아 나오는게 아니라 각자 다름
	//왜?
	//포인터 배열 안에 있는 각각의 주소이기 때문에
	//a,b,c,d는 배열 아니고 연속된 공간 안에 있는 값들 아니니까
	//그냥 얘네의 주소 가지고 나온거임

	cout << endl;

	//포인터의 배열들은 연속된 공간에 있음
	//앰퍼센드 붙여서 연속된 공간에 있음을 확인하자
	cout << &arr[0] << endl; //arr[0]의 주소 (a가 아니라 그 칸의 주소)
	cout << &arr[1] << endl; 
	cout << &arr[2] << endl;
	cout << &arr[3] << endl;
	//이렇게 출력하면 얘네는 4바이트씩 차이나게 나옴을 알 수 있다.
	//연달아서

	cout << endl;

	//각각이 가리키는 값 출력하려면
	cout << *arr[0] << endl; //지정안해줘서 쓰레기값
	cout << *arr[1] << endl; //지정 안해줘서 쓰레기값
	cout << *arr[2] << endl;
	cout << *arr[3] << endl;
	
	//포인터는 다른 언어에선 쉽게 볼 수 없는 기능
	
}